# -*- coding: utf-8 -*-
"""WindDirectionPrediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kCi6jsBF7A9zlBDEM3U3Brcg1ujBEDmR
"""

from pandas import DataFrame
from pandas import Series
from pandas import concat
from pandas import read_csv
from pandas import datetime
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import MinMaxScaler
# from keras.models import Sequential
# from keras.layers import Dense
# from keras.layers import LSTM
from math import sqrt
from matplotlib import pyplot
import numpy as np
import pandas as pd
import joblib

# frame a sequence as a supervised learning problem
def timeseries_to_supervised(data, lag=1):
    df = DataFrame(data)
    columns = [df.shift(i) for i in range(1, lag+1)]
    columns.append(df)
    df = concat(columns, axis=1)
    df.fillna(0, inplace=True)
    return df

# create a differenced series
def difference(dataset, interval=1):
    diff = list()
    for i in range(interval, len(dataset)):
        value = dataset[i] - dataset[i - interval]
        diff.append(value)
    return Series(diff)

# invert differenced value
def inverse_difference(history, yhat, interval=1):
    return yhat + history[-interval]

# scale train and test data to [-1, 1]
def scale(train, test):
    # fit scaler
    scaler = MinMaxScaler(feature_range=(-1, 1))
    scaler = scaler.fit(train)
    # transform train
    train = train.reshape(train.shape[0], train.shape[1])
    train_scaled = scaler.transform(train)
    # transform test
    test = test.reshape(test.shape[0], test.shape[1])
    test_scaled = scaler.transform(test)
    return scaler, train_scaled, test_scaled

# inverse scaling for a forecasted value
def invert_scale(scaler, X, value):
    new_row = [x for x in X] + [value]
    array = np.array(new_row)
    array = array.reshape(1, len(array))
    inverted = scaler.inverse_transform(array)
    return inverted[0, -1]

# make a one-step forecast
def forecast_lstm(model, batch_size, X):
    X = X.reshape(1, 1, len(X))
    #print(X)
    yhat = model.predict(X, batch_size=1)
    return yhat[0,0]

def predict_wind_direction():

  # Initialize some variables
  batch_size_exp = 1
  epoch_exp = 7
  neurons_exp = 10
  predict_values_exp = 72
  lag_exp=24

  # Load the data
  import pandas as pd
  series = pd.read_csv('https://gist.githubusercontent.com/TechTarun/3497b164548f3c7d7a400b2af3c76fdf/raw/c7bf51de73fccec23ac7313129495cb3e8e2cfc4/winddata.csv',index_col="Date/Time")
  del series['LV ActivePower (kW)']
  del series['Wind Speed (m/s)']
  del series['Theoretical_Power_Curve (KWh)']
  print(series.head())

  # transform data to be stationary
  raw_values = series.values
  diff_values = difference(raw_values, 1)

  # transform data to be supervised learning
  supervised = timeseries_to_supervised(diff_values, lag_exp)
  supervised_values = supervised.values

  # split data into train and test-sets
  train, test = supervised_values[:], supervised_values[:]

  # transform the scale of the data
  scaler, train_scaled, test_scaled = scale(train, test)

  # Load the model
  wind_direction_lstm = joblib.load('WindDirectionLSTM.pkl')

  # Make the prediction
  predictions = list()
  expectations = list()
  test_pred = list()
  for i in range(len(test_scaled)):
      if i == 72:
          break
      # make one-step forecast
      X, y = test_scaled[i, 0:-1], test_scaled[i, -1]
      yhat = forecast_lstm(wind_direction_lstm, 1, X)#batch_size_exp to 1
      # Replacing value in test scaled with the predicted value.
      test_pred = [yhat] + test_pred 
      if len(test_pred) > lag_exp+1:
          test_pred = test_pred[:-1]
      if i+1<len(test_scaled):
          if i+1 > lag_exp+1:
              test_scaled[i+1] = test_pred
          else:
              test_scaled[i+1] = np.concatenate((test_pred, test_scaled[i+1, i+1:]),axis=0)

      # invert scaling
      yhat = invert_scale(scaler, X, yhat)
      # invert differencing
      yhat = inverse_difference(raw_values, yhat, len(test_scaled)+1-i)
      # store forecast
      expected = raw_values[len(train_scaled) + i + 1-50519]
      if expected != 0:
          predictions.append(yhat)
          expectations.append(expected)
      
  # Calculate the error
  expectations = np.array(expectations)
  predictions = np.array(predictions)
  print("Mean Absolute Percent Error(wind direction): ", (np.mean(np.abs((expectations - predictions) / expectations))*100))

  # line plot of observed vs predicted
  pyplot.plot(raw_values[:predict_values_exp], label="True")
  pyplot.plot(predictions, label="Predicted")
  pyplot.legend(loc='upper right')
  pyplot.xlabel("Number of hours")
  pyplot.ylabel("wind direction")
  pyplot.show()


############ main ###############
def predict_wind_direction_main():
  predict_wind_direction()
  predictions = predictions.flatten('F')

  index = np.arange(1, 73)
  index.shape
  a = np.zeros_like(index)
  a.shape
  a

  data = dict()
  data['Index'] = index
  data['Wind Speed (m/s)'] = np.zeros_like(index)
  data['Wind Direction (Â°)'] = predictions
  data['LV ActivePower (kW)'] = np.zeros_like(index)
  df = pd.DataFrame(data=data)
  df.to_csv('Future_Data.csv')


